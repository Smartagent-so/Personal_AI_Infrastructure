#!/usr/bin/env bun

/**
 * SessionEnd Hook - Captures session summary for UOCS
 *
 * Generates a session summary document when a Claude Code session ends,
 * documenting what was accomplished during the session.
 */

import { writeFileSync, mkdirSync, existsSync, readFileSync, readdirSync } from 'fs';
import { join } from 'path';
import { PAI_DIR, HISTORY_DIR } from './lib/pai-paths';

interface SessionData {
  conversation_id: string;
  timestamp: string;
  [key: string]: any;
}

async function main() {
  try {
    // Read input from stdin
    const input = await Bun.stdin.text();
    if (!input || input.trim() === '') {
      process.exit(0);
    }

    const data: SessionData = JSON.parse(input);

    // Generate timestamp for filename
    const now = new Date();
    const timestamp = now.toISOString()
      .replace(/:/g, '')
      .replace(/\..+/, '')
      .replace('T', '-'); // YYYY-MM-DD-HHMMSS

    const yearMonth = timestamp.substring(0, 7); // YYYY-MM

    // Try to extract session info from raw outputs
    const sessionInfo = await analyzeSession(data.conversation_id, yearMonth);

    // Generate filename
    const filename = `${timestamp}_SESSION_${sessionInfo.focus}.md`;

    // Ensure directory exists
    const sessionDir = join(HISTORY_DIR, 'sessions', yearMonth);
    if (!existsSync(sessionDir)) {
      mkdirSync(sessionDir, { recursive: true });
    }

    // Generate session document
    const sessionDoc = formatSessionDocument(timestamp, data, sessionInfo);

    // Write session file
    writeFileSync(join(sessionDir, filename), sessionDoc);

    // Exit successfully
    process.exit(0);
  } catch (error) {
    // Silent failure - don't disrupt workflow
    console.error(`[UOCS] SessionEnd hook error: ${error}`);
    process.exit(0);
  }
}

async function analyzeSession(conversationId: string, yearMonth: string): Promise<any> {
  // Try to read raw outputs for this session
  const rawOutputsDir = join(HISTORY_DIR, 'raw-outputs', yearMonth);

  let filesChanged: string[] = [];
  let commandsExecuted: string[] = [];
  let toolsUsed: Set<string> = new Set();
  let firstPrompt: string = '';
  let firstTimestamp: number = 0;
  let lastTimestamp: number = 0;

  try {
    if (existsSync(rawOutputsDir)) {
      const files = readdirSync(rawOutputsDir).filter(f => f.endsWith('.jsonl'));

      for (const file of files) {
        const filePath = join(rawOutputsDir, file);
        const content = readFileSync(filePath, 'utf-8');
        const lines = content.split('\n').filter(l => l.trim());

        for (const line of lines) {
          try {
            const entry = JSON.parse(line);
            // FIX: Use session_id not session
            if (entry.session_id === conversationId) {
              // Track timestamps for duration calculation
              if (entry.timestamp) {
                if (!firstTimestamp || entry.timestamp < firstTimestamp) {
                  firstTimestamp = entry.timestamp;
                }
                if (entry.timestamp > lastTimestamp) {
                  lastTimestamp = entry.timestamp;
                }
              }

              // Capture first user prompt for session naming
              if (entry.hook_event_type === 'UserPromptSubmit' && entry.payload?.prompt && !firstPrompt) {
                firstPrompt = entry.payload.prompt;
              }

              // Track tool usage
              const toolName = entry.payload?.tool_name;
              if (toolName) {
                toolsUsed.add(toolName);
              }

              // Extract file changes
              if (toolName === 'Edit' || toolName === 'Write') {
                if (entry.payload?.tool_input?.file_path) {
                  filesChanged.push(entry.payload.tool_input.file_path);
                }
              }

              // Extract bash commands
              if (toolName === 'Bash' && entry.payload?.tool_input?.command) {
                commandsExecuted.push(entry.payload.tool_input.command);
              }
            }
          } catch (e) {
            // Skip invalid JSON lines
          }
        }
      }
    }
  } catch (error) {
    // Silent failure
  }

  // Calculate duration in minutes
  const durationMs = lastTimestamp - firstTimestamp;
  const durationMinutes = durationMs > 0 ? Math.round(durationMs / 60000) : 0;

  // Generate focus name from first prompt
  const focus = generateFocusName(firstPrompt);

  return {
    focus,
    firstPrompt,
    filesChanged: [...new Set(filesChanged)].slice(0, 10), // Unique, max 10
    commandsExecuted: commandsExecuted.slice(0, 10), // Max 10
    toolsUsed: Array.from(toolsUsed).filter(t => t), // Filter out undefined
    duration: durationMinutes
  };
}

/**
 * Generate a short, filesystem-safe focus name from the first user prompt
 */
function generateFocusName(prompt: string): string {
  if (!prompt || prompt.trim() === '') {
    return 'general-work';
  }

  // Clean the prompt
  let focus = prompt
    .toLowerCase()
    .trim()
    // Remove special characters except spaces and hyphens
    .replace(/[^a-z0-9äöüß\s-]/g, '')
    // Replace multiple spaces with single hyphen
    .replace(/\s+/g, '-')
    // Remove multiple hyphens
    .replace(/-+/g, '-')
    // Trim hyphens from start/end
    .replace(/^-|-$/g, '');

  // Limit to first 40 characters
  if (focus.length > 40) {
    focus = focus.substring(0, 40).replace(/-$/, '');
  }

  // Fallback if empty after cleaning
  return focus || 'general-work';
}

function formatSessionDocument(timestamp: string, data: SessionData, info: any): string {
  const date = timestamp.substring(0, 10); // YYYY-MM-DD
  const time = timestamp.substring(11).replace(/-/g, ':'); // HH:MM:SS

  // Format first prompt for display (truncate if too long)
  const displayPrompt = info.firstPrompt
    ? (info.firstPrompt.length > 200 ? info.firstPrompt.substring(0, 200) + '...' : info.firstPrompt)
    : 'Not captured';

  return `---
capture_type: SESSION
timestamp: ${new Date().toISOString()}
session_id: ${data.conversation_id}
duration_minutes: ${info.duration}
focus: ${info.focus}
executor: kai
---

# Session: ${info.focus}

**Date:** ${date}
**Time:** ${time}
**Session ID:** ${data.conversation_id}
**Duration:** ${info.duration > 0 ? `${info.duration} minutes` : 'Unknown'}

---

## Initial Request

> ${displayPrompt}

---

## Tools Used

${info.toolsUsed.length > 0 ? info.toolsUsed.map((t: string) => `- ${t}`).join('\n') : '- None recorded'}

---

## Files Modified

${info.filesChanged.length > 0 ? info.filesChanged.map((f: string) => `- \`${f}\``).join('\n') : '- None recorded'}

**Total Files Changed:** ${info.filesChanged.length}

---

## Commands Executed

${info.commandsExecuted.length > 0 ? '```bash\n' + info.commandsExecuted.join('\n') + '\n```' : 'None recorded'}

---

## Notes

This session summary was automatically generated by the UOCS SessionEnd hook.

For detailed tool outputs, see: \`\${PAI_DIR}/history/raw-outputs/${timestamp.substring(0, 7)}/\`

---

**Session Outcome:** Completed
**Generated:** ${new Date().toISOString()}
`;
}

main();
